
# 인덱스

- 데이터를 빠르게 찾을 수 있는 하나의 장치. 일종의 목차
- DBMS는 B-tree의 인덱싱을 활용해 특정 데이터를 찾기 위한 읽기 작업의 빈도를 낮춤
- B-tree의 각각의 노드는 메모리에서 하나의 페이지를 담당하여, 각 노드가 최소한 절반을 채워두도록 하여 읽기 접근의 횟수를 줄입니다.

<br>

## B-tree

> 💡 **B-Tree는 무슨 줄임말인가?**
> B-트리의 창시자인 루돌프 바이어는 ‘B’가 무엇을 의미하는지 따로 언급하지는 않았다. 가장 가능성 있는 대답은 리프 노드를 같은 높이에서 유지시켜주므로 균형잡혀있다(balanced)는 뜻에서의 ‘B’라는 것이다. ‘바이어(Bayer)’의 ‘B’를 나타낸다는 의견도, 혹은 그가 일했던 보잉 과학 연구소(Boeing Scientific Research Labs)에서의 ‘B’를 나타낸다는 의견도 있다.

> 💡 **Btree는 정렬된 순서를 보장하고, 멀티레벨 인덱싱을 통한 빠른 검색을 할 수 있기 때문에 DB에 사용한다.**

B트리는 이진트리와 다르게 하나의 노드에 많은 수의 정보를 가지고 있을 수 있다. **최대 m개의 자식**을 가질 수 있는 B트리를 **m차 B트리**라고 하며 다음과 같은 특징을 가진다.


**특징**
-   **모든 리프 노드**는 **같은 레벨**에 있다 (**perfectly balanced**)
-   **루트 노드**는 **리프 노드**이거나 **최소 2개의 자식 노드**가 있다.
-   루트 노드와 리프 노드가 아닌 **노드**는 **_m_/2개**부터 **최대 _m_개**까지의 **자식**을 가질 수 있다.
-   노드에는 **최대 _m_−1개 부터 [_m_/2]−1개의 key**가 포함될 수 있다.
-   노드의 **key가 _x_개**라면 **자식의 수는 _x_+1개**이다.
-   **최소차수**는 **자식수의 하한값**을 의미하며, **최소차수가 t**라고 하면 **m=2t−1**을 만족한다. (최소차수 t가 2라면 3차 B트리이며, key의 하한은 1개)


![[Pasted image 20230312011124.png]]


## **B+tree**
: B-tree의 변형 구조

-  **index 부분**과 **리프 노드로 구성된 순차 데이터 부분**으로 이루어짐
- 즉, B-tree의 그림에서는 편의상 data를 생략해서 그렸지만 각 key값이 data를 가지고 있었고, B+tree의 경우에는 인덱스 부분의 key 값은 리프 노드에 있는 key 값을 직접 찾아가는데 사용한다고 생각하면 됨

- 동작 방식의 다른점이라고 하면 **리프 노드가 연결리스트의 형태**를 띄어 **선형 검색이 가능하다**. 이러한 특징점 때문에 **굉장히 작은 시간복잡도**에 **검색**을 수행할 수 있다.

- 이런 장점들 때문에 모든 RDBMS에서 B+ Tree를 지원하고 있으며, 거의 모든 file system에서도 B+Tree를 사용한다.

> 💡 실제 **DB의 인덱싱은 B+트리**로 이루어져있다고 한다. 다음 그림은 인덱싱을 나타낸 것이다. 인덱싱은 어떠한 자료를 찾는데 key값을 이용해 효과적으로 찾을 수 있는 기능이다. 
> ![Untitled 5](https://user-images.githubusercontent.com/100582309/165692074-35ea7971-894e-49fd-88aa-ab9dbd3fb7b9.png)  
> 
> 다음과 같은 인덱싱을 **B+트리**로 나타내면 아래 그림과 같습니다.  
> ![Untitled 6](https://user-images.githubusercontent.com/100582309/165692057-b3f1e320-73a7-4a45-8b24-db2288328d77.png)


### B+tree가 B-tree와 다른 점

1.  **모든 key, data가 리프노드에 모여있다.**
    B트리는 리프노드가 아닌 각자 key마다 data를 가진다면, B+트리는 리프 노드에 모든 data를 가진다.

1.  **모든 리프노드가 연결리스트의 형태를 띄고 있다.**
    B트리는 옆에있는 리프노드를 검사할 때, 다시 루트노드부터 검사해야 한다면, B+트리는 리프노드에서 선형검사를 수행할 수 있어 시간복잡도가 굉장히 줄어든다.

3.  **데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드(Non-Leaf)가 있다.**
    기존의 B-Tree와 데이터의 연결리스트로 구현된 색인구조. 데이터의 빠른 접근을 위한 인덱스 역할만 한다.
   
4.  key 값을 기준으로 **왼쪽 pointer**는 key 값보다 **작은** key 값의 노드를, key 값을 기준으로 **오른쪽 pointer**는 key 값보다 **크거나 같은** key 값의 노드를 가리킨다.


#### **장점**
-   **블록 사이즈를 더 많이 이용할 수 있음**
    - key 값에 대한 하드디스크 액세스 주소가 없기 때문이다.
    - 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용할 수 있다. 
    - 하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.
    -  cache hit를 높일 수 있다.

-   **리프 노드끼리 연결 리스트로 연결되어 있어서 범위 탐색에 매우 유리**    
    ex : Full scan시 선형탐색 1번이면 된다.


##### 단점
-  B-tree의 경우 최상 케이스에서는 루트에서 끝날 수 있지만, B+tree는 무조건 리프 노드까지 내려가봐야 함

<br>

## 인덱스와 대수 확장성

- 인덱스가 효율적인 이유 : 효율적인 단계를 거쳐, 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조를 사용하기 때문! 트리 깊이의 대수확장성과 관련이 있다.

##### 대수 확장성
- 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 성질
- 기본적으로 인덱스가 한 깊이씩 증가할 때마다, 최대 인덱스 항목의 수는 4배씩 증가함

<br>

## DBMS와 인덱스

### MySQL의 인덱스

#### **종류**
- 클러스터형 인덱스
- 세컨더리 인덱스

#### **생성 방법**

**클러스터형 인덱스**
- 테이블당 하나 설정 가능
- primary key 옵션으로 기본키를 만들면 인덱스 생성됨
- unique not null 옵션 붙이면 인덱스 생성 가능

**세컨더리 인덱스**
- create index ...  명령어를 기반으로 만들면 생성 가능
- 보조인덱스. 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 함
> 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋음


### MongoDB의 인덱스

- 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정됨
- 세컨더리키도 부가적으로 설정 가능
- 기본키, 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있음

<br>

## 인덱스 최적화 기법

> 데이터베이스마다 조금씩 다르지만, 기본적인 골조는 똑같음.
> 아래는 MongoDB를 기반으로 한 인덱스 최적화 기법을 설명함


#### 1. 인덱스도 결국 비용이 든다.
- 인덱스 리스트, 그 다음 컬렉션 순으로 탐색한다. 관련 읽기 비용이 발생한다.
- 컬렉션이 수정되었을 때, 인덱스도 수정되어야 한다. B-tree 높이를 균형 있게 조정하는 비용도 들고, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들음
>👉🏻 쿼리의 모든 필드에 인덱스를 무작정 다 설정하는 것은 답이 아님. 또, 컬렉션에서 가져와야 하는 양이 많을수록, 인덱스 사용이 비효율적일 수도 있음



#### 2. 항상 테스팅하라.

- 서비스에 따라 인덱스 최적화 기법이 다르기 때문에, 결국 항상 직접 테스팅하는 것이 가장 중요!
- `explain()` 함수를 통해 인덱스를 만들고, 쿼리를 보낸 후에 테스팅을 하며 걸리는 시간을 최소화하기
- MySQL 코드 최적화 테스팅 방법
	```sql
	EXPLAIN
	SELECT * FROM t1
	JOIN t2 ON t1.c1 = t2.c1
	```


### 3. 복합 인덱스는 같음 → 정렬 → 다중값 → 카디널리티 순
- 여러 필드를 기반으로 조회할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고, 순서에 따라 인덱스 성능이 달라진다.
- 바람직한 순서는 같음, 정렬, 다중값, 카디널리티 순이다.
    > 카디널리티 : 유니크한 값의 정도

1. `==`, `equal`
2. 정렬에 쓰이는 필드
3. 다중 값을 출력해야 하는 필드. 즉, 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면, 나중에 인덱스를 설정하기
4. 카디널리티가 높은 순서를 기반으로 인덱스 생성