
# 운영체제란?

운영체제는 컴퓨터의 하드웨어를 총체적으로 관리하는 소프트웨어입니다. 

이는 사용자와 컴퓨터 하드웨어, 어플리케이션과 컴퓨터 하드웨어 사이를 중개하는 역할도 합니다. 

>컴퓨터란?
   : CPU, 메모리 등으로 이루어진 것

>펌웨어란?
   : 운영체제와 유사하지만 소프트웨어를 추가로 설치할 수 없는 것


## 운영체제가 하는 일

컴퓨터의 시스템은 하드웨어, 운영체제, 어플리케이션 프로그램, 사용자 이렇게 4가지로 나눌 수 있습니다.

하드웨어는 크게 CPU, memory, I/O device 로 나눌 수 있습니다. 이 하드웨어들은 기본적인 컴퓨터 자원이라고도 불립니다. 워드 프로세서, 엑셀, 컴파일러, 웹브라우저 등 어플리케이션 프로그램들은 컴퓨터 자원(하드웨어) 를 사용하여 사용자의 computing problem 들을 해결합니다. 

여기에서 운영체제는 
- 이 **하드웨어를 컨트롤**하고
- 다양한 **어플리케이션 프로그램들이 사용할 수 있도록 조정하는 역할**을 합니다. 



## 운영체제의 역할

**1. CPU 스케줄링과 프로세스 관리**
	CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환 관리

**2. 메모리 관리**
	한정된 메모리를 어떤 프로세스에 얼만틈 할당해야 하는지 관리

**3. 디스크 파일 관리**
	디스크 파일을 어떠한 방법으로 보관할지 관리

**4.  I/O 디바이스 관리**
	I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리함



## 운영체제의 구조

![[Pasted image 20230217010159.png]]
※ GUI가 없고 CUI만 있는 리눅스 서버도 있음

>**GUI** 
  : 사용자가 전자장치와 상호작용할 수 있도록 하는 사용자 인터페이스의 한 형태. 단순 명령어 창이 아닌, 아이콘을 마우스로 클릭하는 단순한 동작으로 컴퓨터와 상호작용할 수 있도록 해줌

>**드라이버**
  : 하드웨어를 제어하기 위한 소프트웨어

>**CUI**
  : 그래픽이 아닌 명령어로 처리하는 인터페이스



### **프로세스/스레드의 요청 전달 과정**

![[Pasted image 20230217025007.png]]
프로세스/스레드 -> 시스템콜 -> 커널 -> OS


> **시스템콜**
> 운영체제가 커널에 접근하기 위한 인터페이스
> 유저 프로그램이 운영 체제의 서비스를 받기 위해 커널 함수를 호출할 때 쓰인다. 이 과정을 통해 컴퓨터 자원에 대한 직접 접근을 차단하고, 프로그램을 다른 프로그램으로부터 보호할 수 있다. 
>
>시스템콜이 작동될 때 Modebit을 참고해서 유저모드와 커널 모드를 구분한다. modebit은 1 또는 0의 값을 가지는 플래그 변수. (0 = 커널 모드, 1 = 유저 모드)

![[Pasted image 20230217142101.png]]



>**유저 모드**
>: 유저가 접근할 수 있는 영역이 제한적임. 컴퓨터 자원에 함부로 침범하지 못 하는 모드

>**커널 모드**
>: 모든 컴퓨터 자원에 접근할 수 있는 모드


>**커널**
>: 운영체제의 핵심 부분이자 시스템콜 인터페이스를 제공하며, 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추적인 역할

> **그래서 운영체제란?**
> 사실 운영체제는 컴퓨터, 토스터기, 차, 선박, 우주선, 가구 등 다양한 기기들 안에 다양한 형태로 존재함. 이렇게 운영체제는 다양한 형태로 존재하므로 적합한 정의를 하는건 쉽지 않다. 
>
	그러나 다양한 운영체제의 일반적이고 공통적인 부분을 모으면, 운영체제는 컴퓨터에서 **항상 실행되는 프로그램** 이라고 정의할 수 있고 이는 **kernel** 이라고도 불리기도 한다.

---


## 컴퓨터의 요소

CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등

![[Pasted image 20230217142913.png]]

1.  CPU(Central Processing Unit) : 프로그램의 연산을 실행, 처리하는 곳
2.  DMA 컨트롤러 : I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 장치
3.  메모리 : RAM을 일컫음, 기록하는 장치
4.  타이머 : 특정 프로그램에 시간 제한 걺. 시간이 많이 걸리는 프로그램에 제한을 걸기 위해 존재
5.  디바이스 컨트롤러 : IO 디바이스들의 작은 CPU


### 1.  CPU
- 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치로 구성
- 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행하는 일꾼

1) 제어장치
	- 프로세스 조작을 지시하는 CPU의 한 부품
	- 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정

2) 레지스터
	- CPU 안에 있는 매우 빠른 임시저장장치
	- 연산속도가 메모리보다 수십 배에서 수백 배까지 빠르다.

3) 산술논리연산장치
	- 산술 연산과 논리 연산을 계산하는 디지털 회로

4) 인터럽트
	- 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것
	- 인터럽트 간에는 우선순위가 있다.
	- 하드웨어 인터럽트 : IO 디바이스에서 발생하는 인터럽트
	- 소프트웨어 인터럽트 : 트랩이라고도 한다. 프로세스가 시스템콜을 호출할 때 발동


### 2.  DMA 컨트롤러
-   I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치
-   CPU에만 너무 많은 인터럽트 요청이 들어오기 때문에 CPU 부하를 막아주며 CPU의 일을 부담하는 보조 일꾼


### 3.  메모리
-   데이터나 상태, 명령어 등을 기록하는 장치
-   RAM을 일컬어 메모리라고 함
-   CPU는 계산 담당, 메모리는 기억 담당



# 자원 관리자로서의 운영체제

앞서 본 것처럼 운영체제는 resource manager이다. Resource manager 로서 운영체제는 시스템의 CPU, 메모리, storage, I/O 장치 등의 resource 들을 관리해야 한다.

## 메모리 계층

램은 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 이를 필요시마다 CPU에 빠르게 전달하는 역할을 함

1.  레지스터 : CPU안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적음
2.  캐시 : L1, L2캐시를 지칭
3.  주기억장치 : 메모리 즉 RAM 지칭
4.  보조기억장치 : HDD, SDD 지칭

＊*계층이 위로 올라갈수록 가격은 비싸지는데 용량은 작아지고 속도는 빨라짐
＊계층이 있는 이유는 경제성과 캐시 때문!




# Caching

캐싱은 컴퓨터 시스템의 중요한 개념 중 하나이다.

정보는 보통 어떤 저장장치에 보관되는데, 정보가 저장된 저장공간에 따라 불러오는 속도가 다르다. 예를 들어 main memory 에 있는 프로그램이나 데이터들은 mass-storage 에서 불러올 때보다 훨씬 빠르게 불러옵니다. 

그러나 중복되어 불려지는 데이터나 프로그램의 부분은 더욱 빨리 불러와질 필요가 있었고, 이를 위해 우리는 더 빠른 장치인 캐시에 해당 데이터를 저장하여 불러와 성능을 향상시킬 수 있다.

그러나 캐시는 크기가 제한되어 있기 때문에 캐시 관리는 중요한 설계 문제로 성능을 크게 좌지우지한다. 


## Cache

: 데이터를 미리 복사해놓는 임시저장소

-   빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
	→ 메모리와 CPU 사이의 속도차이가 너무 커서 그 중간에 레지스터 계층을 두어 속도 차이를 해결한다.
	
	 → 이러한 속도 차이를 위해 만든 계층을 캐싱 계층이라 한다.

- 캐시의 직접 설정
	: 자주 사용하는 데이터를 기반으로 설정해야 함
	
	자주 사용하는 데이터에 대한 근거?
	
	 → **지역성의 원리**
			1) 시간 지역성 : 최근 사용한 데이터에 다시 접근하려는 특성
			2) 공간 지역성:  최근 접근한 데이터를 이루고 있는 공간 혹은 그 근접 공간에 접근하는 특성


## Cache Hit
: 캐시에서 원하는 데이터를 찾은 것

## Cache Miss
: 해당 데이터가 캐시에 없다면 주 메모리로 가서 데이터를 찾아오는 것

![[Pasted image 20230217144647.png]]


## Cache Mapping
: 캐시가 히트되기 위해 하는 매핑

-   CPU의 레지스터와 주 메모리(RAM) 간에 데이터를 주고 받을 때를 기반으로 설명

1) 직접 매핑 : 처리가 빠르지만 충돌 발생이 잦음
2) 연관 매핑 : 순서를 일치 X. 관련 있는 캐시와 메모리를 매핑. 충돌이 적지만 모든 블록을 탐색해야 해서 속도 느림
3) 집합 연관 매핑 : 직접 매핑과 연관 매핑을 합쳐 놓은 것. 순서는 일치시키지만 집합을 둬서 저장하며, 블록화되어 있기 때문에 검색은 좀 더 효율적임


## 웹 브라우저의 캐시

-   **쿠키**
	- 만료기한이 있는 키-값 저장소
	- 4KB까지 데이터를 저장할 수 있고 만료 기한을 정할 수 있음
	- 쿠키 설정시 : document cookie로 쿠키를 볼 수 없게 httponly섷정 거는 것이 중요함
	- 클라이언트 혹은 서버에서 만료기한 설정 - 보통 서버에서 정함

- **로컬 스토리지**
	- 만료기한이 없는 키-값 저장소
	- 10MB까지 저장 가능
	- 웹 브라우저를 닫아도 유지되고 도메인 단위로 저장, 생성
	- 클라이언트에서만 수정 가능
	- HTML5 지원 브라우저에서만 가용 가능

- **세션 스토리지**
	- 만료기한이 없는 키-값 저장소
	- 5MB까지 저장 가능
	- 탭 단위로 세션 스토리지를 생성, 탭을 닫을 때 해당 데이터가 삭제
	- 클라이언트에서만 수정 가능
	- HTML5 지원 브라우저에서만 가용 가능



## 데이터베이스의 캐싱 계층

![[Pasted image 20230217145814.png]]
데이터베이스 위에 레디스 데이터 베이스 게층을 ‘캐싱 계층’으로 두어 성능을 향상시키기도 함



# 메모리 관리

### 1. 가상 메모리

-   컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 사용자들에게 매우 큰 메모리로 보이게 만드는 것
-   가상 메모리는 가상 주소와 실제 주소가 매핑되어 있음
-   프로세스의 주소 정보가 들어있는 ‘페이지 테이블’로 관리

**스와핑**
-   당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고, 사용하지 않으면 다시 하드디스크로 내림을 반복하여 RAM을 효과적으로 관리하는 것
-   가상 메모리에는 존재하지만 실제 RAM에는 없는 데이터에 접근할 때 발생하는 페이지 폴트를 방지하기 위함

**페이지 폴트**
-   프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우 발생


### 2. 스레싱

-   메모리의 페이지 폴트율이 높은 것 → 심각한 성능 저하를 초래
-   메모리에 너무 많은 프로세스가 동시에 올라가면 스와핑이 많이 일어나서 발생
-   페이지 폴트 발생 → CPU 이용률 낮아짐 → 더 많은 프로세스를 메모리에 올림 → 악순환 반복… ⇒ 스레싱 발생

>**_운영체제에서 스레싱을 해결하는 법_**
>1) 작업세트
>	프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드
>2) PFF (Page Fault Frequency)
		페이지 폴트 빈도를 조절하는 방법. 상한선과 하한선을 만들어, 상한선에 도달하면 페이지를 늘리고 하한선에 도달하면 페이지를 줄임


### 3. 메모리 할당
-   시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당

**연속 할당**
-   프로세스를 순차적으로 공간에 할당하는 것
-   고정 분할 방식 : 메모리를 미리 나누어 관리
-   가변 분할 방식 : 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용

**불연속 할당**
-   페이징 : 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당
-   세그멘테이션 : 의미단위인 세그먼트로 나눈다.
-   페이지드 세그멘테이션 : 공유나 보안을 의미 단위의 세그먼트로 나누고, 물리적 메모리는 페이지로 나누는 것


### 4. 페이지 교체 알고리즘

- 페이지 교체 알고리즘을 기반으로 스와핑 발생

**오프라인 알고리즘**
: 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 것

**FIFO (First In First Out)**
: 가장 먼저 온 페이지를 교체 영역에 먼저 놓는 방법

**LRU (Least Recentle Used)**
-   참조가 가장 오래된 페이지를 바꾸는 것
-   해시 테이블과 이중 연결 리스트로 구현

**LFU (Least Frequently Used)**
: 가장 참조 횟수가 적은 페이지를 교체 (많이 사용되지 않은 것)



### 참고 문헌

Operating System Concepts 10th (공룡책)

양햄찌님 블로그 : [https://jhnyang.tistory.com/16](https://jhnyang.tistory.com/16)

Suhwanc님 블로그 : [https://suhwanc.tistory.com/175](https://suhwanc.tistory.com/175)

angie님 블로그 : https://velog.io/@94applekoo/CS-3.1-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%BB%B4%ED%93%A8%ED%84%B0
